board를 입력받으면 temp에다가 카드짝의 형태로 좌표들을 담음.

temp[0] => 1번카드 짝들의 좌표 ex) {{0,0},{3,2}} 
temp[1] => 2번카드 짝들의 좌표 ex) {{1,0},{2,3}}
.....

그러면 do while(next_permutation)에 의해

첫번째 시행	1번카드 -> 2번카드 -> 3번카드
두번째 시행	1번카드 -> 3번카드 -> 2번카드
세번쨰 시행	2번카드 -> 1번카드 -> 3번카드
네번쨰 시행	2번카드 -> 3번카드 -> 1번카드
다섯번째 시행	3번카드 -> 1번카드 -> 2번카드
여섯번쨰 시행	3번카드 -> 2번카드 -> 1번카드

========================
0 0	3 2        1번카드
1 0  	2 3	2번카드
0 3	3 0	3번카드
======================
첫번째 시행 예시
======================
1 0	3 2
3 2	0 0
0 0	2 3		1(2,1) -> 2(2,1) -> 3(2,1)
2 3	1 0
1 0	3 0
3 0	0 3

1 0	0 0
0 0	3 2
3 2	2 3		1(1,2)-> 2(2,1) -> 3(2,1)
2 3	1 0
1 0	3 0
3 0	0 3

1 0	3 2
3 2	0 0
0 0	1 0
1 0	2 3		1(2,1) -> 2(1,2) -> 3(2,1)
2 3	3 0
3 0	0 3

1 0	0 0
0 0	3 2
3 2	1 0		1(1,2) -> 2(1,2) -> 3(2,1)
1 0	2 3
2 3	3 0
3 0	0 3

1 0	3 2
3 2	0 0
0 0	2 3		1(2,1) -> 2(2,1) -> 3(1,2)
2 3	1 0
1 0	0 3
0 3	3 0

1 0	0 0
0 0	3 2
3 2	2 3		1(1,2)-> 2(2,1) -> 3(1,2)
2 3	1 0
1 0	0 3
0 3	3 0

1 0	3 2
3 2	0 0
0 0	1 0		1(2,1) -> 2(1,2) -> 3(1,2)
1 0	2 3
2 3	0 3
0 3	3 0

1 0	0 0
0 0	3 2
3 2	1 0		1(1,2) -> 2(1,2) -> 3(1,2)
1 0	2 3
2 3	0 3
0 3	3 0

=====================================
organizePair를 거쳐서 나온 vector<vector<pair<int,int>>> organizedPair는
모든 각각의 시행에 대한 좌표들이 순서대로 나열되어 있음.
ex) organizedPair[0]은 첫번째 시행이니까 시작점 -> 1(2,1)-> 2(2,1) ->3(2,1)
{{1,0}, {3,2}, {0,0}, {2,3}, {1,0}, {3,0}, {0,3}} 0번 요소

이 organizedPair를 for문을 돌려서 각각의 점으로 이동하는데 걸리는 횟수를 BFS해서 찾고
tempI에 저장해주고 짝을 맞춰 사라진 카드는 보드에서 비워주며 각각 시행의 총 BFS합을
후보군에 저장해둔다.

후보군중에서 최솟값이 정답이 된다.